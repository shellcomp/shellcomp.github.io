{
  "name": "Shellcomp",
  "tagline": "Shell autocompletion format",
  "body": "# Command line completion\r\n\r\nCommand line (aka tab) completion is popular in the Unix world as it helps typing speed, prevents typos and makes the shell more user-friendly.\r\n\r\n## The problem\r\n\r\nImpementing filename completion is easy. Implementing command-specific completion (e.g. git com<tab>)) is not.\r\n\r\nCompletion scripts are different across Bash, Zsh and Fish.\r\n\r\nTime consuming to implement, sometimes out of date, hacky.\r\n  https://anonscm.debian.org/cgit/bash-completion/debian.git/tree/completions\r\n\r\n## A modest proposal\r\n\r\nCompletion is implemented in the command about to be run:\r\nThe shell run the command with a specific `--tabcomplete '<partial_string>'` option.\r\nThe command responds with simple JSON structure that the shell will parse to perform completion or display help messages.\r\n\r\nBenefits:\r\n\r\n* Shell-independent\r\n* Able to suggest alternative commands and provide contextual help\r\n* Discoverable: the completion mechanism can be queried programmatically to generate documentation, manpages, simple GUIs, run tests.\r\n\r\n### The JSON format\r\n\r\nThe JSON document is to be printed to stdout; All fields are optional:\r\n\r\nv\r\n  version.\r\ncompletions\r\n  a list of valid completion values with an optional help message.\r\nalt\r\n  alternative completions: other commands that the user might want to use.\r\nhelp\r\n  contextual help message.\r\n\r\nAn example response for \"git con<TAB>\"\r\n\r\n.. code-block:: javascript\r\n\r\n    {\r\n        \"v\": 1,\r\n        \"completions\": [\r\n            [\"config\", \"get and set repository or global options\"],\r\n        ]\r\n        \"alt\": [\r\n            [\"commit\", \"record changes to repository\"]\r\n        ]\r\n        \"help\": \"\",\r\n    }\r\n\r\n\r\n**Fields usage:**\r\n\r\nv\r\n  format version. Should be 1.\r\ncompletions\r\n  a list of valid completion values in format [\"completion string\", \"help string\"]. The help string can be empty. An empty list means that no more arguments are expected. An item with an empty completion string means that non-completable user input is expected (e.g. touch <new_filename>).\r\nalt\r\n  alternative completions. Some structure as \"completions\", it contains suggestions about other commands that the user might want to use instead.\r\n  If the \r\nhelp\r\n  contextual help message. It can contain newlines or be empty.\r\nerrpos\r\n  if the user-supplied string contains a syntax error, this is the position of the first error, counting from 0 from the left.\r\nfiles\r\n  a list of filenames, in case the current argument is meant to be an existing file. Using a different field other than \"completions\" allow shells to display the filenames in different colors\r\n\r\n**How to implement it.**\r\n\r\n\r\nIn the long term, popular shells like Bash, Zsh, Fish could implement the standard internally.\r\n\r\nIn the short term, a simple wrapper could run the application on behalf of the shell and perform \"traditional\" completion. \r\n\r\nApplications could implement completion autonomously or through helper libraries\r\nlike `DocOpt <http://docopt.org/>`_ or `Click <http://click.pocoo.org/5/>`_\r\n\r\nFAQ\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}